Exemplu: problema turnurilor din Hanoi, folosind o procedura recursiva;

* enuntul problemei:
  avem 3 pari (numerotati 1,2,3); pe parul 1 avem o stiva de n discuri, cu
 diametrele descrescatoare de la baza spre varf; putem face mutari - o mutare
 consta in mutarea discului de sus de pe un par pe altul, cu conditia sa nu-l
 punem peste un disc mai mic decat el; vrem o succesiune de mutari prin care
 tot teancul de discuri sa fie mutat de pe parul 1 pe parul 3;
* solutie (de complexitate exponentiala):
  notam h(k,a,b,c) = succesiunea de mutari necesare mutarii unei stive de pe
 parul a pe parul b, folosind parul c ca auxiliar; atunci:
  daca k=1, h(1,a,b,c)=ab;
  daca k>1, h(k,a,b,c)=h(k-1,a,c,b) ab h(k-1,c,b,a)
 (intr-adevar, cand deplasam primele k-1 discuri il putem ignora pe cel de-al
 k-lea, care este cel mai mare si este jos de tot - deci putem pune orice
 peste el);
* implementare:
 mutarile succesive vor fi scrise intr-un vector "m" de word ca perechi de
  numere (1,2 sau 1,3 sau 2,3);
 vom folosi o procedura h(k,a,b,c) cu 4 parametri word (primul e nr. de
  discuri ce trebuie mutate, ultimii sunt parii folositi in ordinea descrisa
  mai sus); ea va lucra astfel:
    daca k=1, atunci scrie in "m" (de la pozitia curenta): a,b;
    altfel, apeleaza (recursiv) h(k-1,a,c,b), apoi scrie in "m" (de la
      pozitia curenta) a,b, apoi apeleaza recursiv h(k-1,c,b,a);
 pozitia curenta in "m" va fi urmarita global cu $s0;
 in programul principal vom apela h(n,1,3,2);
programul este:

.data
  m: .space 400
  n: .word 3
.text
main:
  la $s0,m     # $s0 va contine mereu adresa word-ului curent din m
  subu $sp,16  # incarcam parametrii pentru h(n,1,3,2), conform conventiei C
  li $t0,2
  sw $t0,12($sp)
  li $t0,3
  sw $t0,8($sp)
  li $t0,1
  sw $t0,4($sp)
  lw $t0,n
  sw $t0,0($sp)
  jal h         # h(n,1,3,2)
  addu $sp,16   # descarcam stiva de parametrii actuali
    # acum m contine 1,3,1,2,3,2,1,3,2,1,2,3,1,3
li $v0,10
syscall
h:
  subu $sp,8
  sw $ra,4($sp)
  sw $fp,0($sp)
  addiu $fp,$sp,4
    # $sp:($fp v)$fp:($ra v)(k)(a)(b)(c)...
  lw $t0,4($fp)
  li $t1,1
  beq $t0,$t1,et1
    # daca k>1 fac h(k-1,a,c,b)
    subu $sp,16
    lw $t0,12($fp)
    sw $t0,12($sp)
    lw $t0,16($fp)
    sw $t0,8($sp)
    lw $t0,8($fp)
    sw $t0,4($sp)
    lw $t0,4($fp)
    subu $t0,1
    sw $t0,0($sp)
    jal h
    addu $sp,16
  et1: # scriu a,b
    lw $t0,8($fp)
    sw $t0,0($s0)
    lw $t0,12($fp)
    sw $t0,4($s0)
    addu $s0,8
  lw $t0,4($fp)
  li $t1,1
  beq $t0,$t1,et2
    # daca k>1 fac h(k-1,c,b,a)
    subu $sp,16
    lw $t0,8($fp)
    sw $t0,12($sp)
    lw $t0,12($fp)
    sw $t0,8($sp)
    lw $t0,16($fp)
    sw $t0,4($sp)
    lw $t0,4($fp)
    subu $t0,1
    sw $t0,0($sp)
    jal h
    addu $sp,16
  et2:
  lw $ra,0($fp)
  lw $fp,-4($fp)
  addu $sp,8
jr $ra
##########

Comentarii:
- pentru a testa a doua oara daca k>1 (inainte de a face h(k-1,c,b,a)) a
 trebuit sa reincarcam $t0, $t1 cu aceleasi valori, deoarece i-am alterat de
 exemplu la scrierea lui a,b si oricum ei nu s-au pastrat in urma apelului
 h(k-1,a,c,b);
- evolutia stivei este (am notat ram = adresa de retur din program, adica
 $ra salvat la primul nivel de apel al lui h, rah = adresa de retur din
 procedura, adica $ra salvat la nivelele superioare de apel al lui h, fpi =
 diverse valori ale lui $fp salvate de apeluri (am desenat deasupra si unde
 pointeaza ele):

h(3,1,3,2):
|(fp0)(ram)(3)(1)(3)(2)
|h(2,1,2,3):                fp1
||                           V
||(fp1)(rah)(2)(1)(2)(3)(fp0)(ram)(3)(1)(3)(2)
||
||h(1,1,3,2):                fp2                   fp1
|||                           V                     V
|||(fp2)(rah)(1)(1)(3)(2)(fp1)(rah)(2)(1)(2)(3)(fp0)(ram)(3)(1)(3)(2)
|||
||| ==> se scrie: 13
|||_
||
||==> se scrie: 12          fp1
||                           V
||(fp1)(rah)(2)(1)(2)(3)(fp0)(ram)(3)(1)(3)(2)
||
||h(1,3,2,1):                fp2                   fp1
|||                           V                     V
|||(fp2)(rah)(1)(3)(2)(1)(fp1)(rah)(2)(1)(2)(3)(fp0)(ram)(3)(1)(3)(2)
|||
||| ==> se scrie: 32
|||_
||_
|
|==> se scrie: 13
|
|(fp0)(ram)(3)(1)(3)(2)
|
|h(2,2,3,1):                fp1
||                           V
||(fp1)(rah)(2)(2)(3)(1)(fp0)(ram)(3)(1)(3)(2)
||
||h(1,2,1,3):                fp2                   fp1
|||                           V                     V
|||(fp2)(rah)(1)(2)(1)(3)(fp1)(rah)(2)(2)(3)(1)(fp0)(ram)(3)(1)(3)(2)
|||
||| ==> se scrie: 21
|||_
||
||==> se scrie: 23          fp1
||                           V
||(fp1)(rah)(2)(2)(3)(1)(fp0)(ram)(3)(1)(3)(2)
||
||h(1,1,3,2):                fp2                   fp1
|||                           V                     V
|||(fp2)(rah)(1)(1)(3)(2)(fp1)(rah)(2)(2)(3)(1)(fp0)(ram)(3)(1)(3)(2)
|||
||| ==> se scrie: 13
|||_
||_
|_

2)calculul lui n! folosind o functie recursiva (pe baza metodei:
daca n<=1 atunci n!=1, altfel n!=n*(n-1)!, iar pt. (n-1)! se
  apeleaza recursiv aceeasi functie); parametrii si valoarea returnata se
  transmit prin stiva:

.data
  n: .word 3
  x: .space 4
.text
main:
  subu $sp,4 # incarcam in stiva parametrul actual
  lw $t0,n
  sw $t0,0($sp)
  jal fact
  lw $t0,0($sp)
  addu $sp,4 # am convenit ca fct. sa ret. prin stiva si descarcam val. ret.
  sw $t0,x   # acum x contine 6
li $v0,10
syscall
fact:
  subu $sp,8
  sw $ra,4($sp)
  sw $fp,0($sp)
  addiu $fp,$sp,4 # $sp:($fp v)$fp:($ra v)(n)...
  lw $t0,4($fp)
  li $t1,1
  bgt $t0,$t1,et  # test n>1
    sw $t1,4($fp) # daca n<=1 plasez val. ret. 1 (din $t1) in stiva si inchei
    b sf
  et:
    subu $t0,1    # $t0 inca contine n
    subu $sp,4
    sw $t0,0($sp)
      # $sp:(n-1)($fp v)$fp:($ra v)(n)...
    jal fact
      # $sp:((n-1)!)($fp v)$fp:($ra v)(n)...
    lw $t0,0($sp)
    addu $sp,4      # $t0=(n-1)!, $sp:($fp v)$fp:($ra v)(n)...
    lw $t1,4($fp)   # $t1=n
    mul $t1,$t1,$t0 # $t1=n!
    sw $t1,4($fp)   # plasez val. ret. in stiva
  sf: # indiferent cum ajung aici avem $sp:($fp v)$fp:($ra v)(n!)...
  lw $ra,0($fp)
  lw $fp,-4($fp)
  addu $sp,8
jr $ra
##########

Comentariu: la adancimea maxima, stiva ajunge (ca mai inainte, am notat
 ram = adresa de retur din program, adica $ra salvat la primul nivel de apel
 al lui fact, raf = adresa de retur din functie, adica $ra salvat la nivelele
 superioare de apel al lui fact, fpi = diverse valori ale lui $fp salvate de
 apeluri (am desenat deasupra si unde pointeaza ele):

                      fp2          fp1
                       V            V
 $sp:(fp2)(raf)(1)(fp1)(raf)(2)(fp0)(ram)(3)

 Notam ca daca intram de multe ori in apeluri fara sa mai si iesim sau daca
incarcam parametri multi si/sau mari, la un moment dat spatiul stiva se va
umple iar stiva va invada alte zone (de cod, date, etc.) ceea ce se soldeaza
de obicei cu blocarea sau terminarea anormala a programului (de exemplu o
recursie infinita va produce la un moment dat stack overflow).

3)Emularea unui interpretor de comenzi de tip "command.com" foarte
restrans: accepta de la intrare doar comenzi de un caracter,
 in fiecare caz efectul fiind scrierea la iesire a cate unui alt caracter;
 comenzile suportate si caracterul scris la exec. fiecareia din ele sunt:
  comanda 'a' --> caracterul '+' (adunare)
  comanda 's' --> caracterul '-' (scadere)
  comanda 'n' --> caracterul '!' (negare)
 pe langa aceste comenzi mai accepta si:
  comanda 't' --> produce terminarea programului
 daca la intrare vine alt caracter decat 'a', 's', 'n', se va scrie 'e'
 (eroare) - acest lucru se va realiza cu o comanda suplimentara (care se va
 executa automat in asemenea cazuri);
  fluxul de intrare va fi simulat printr-un string ce contine o succesiune de
 caractere (nume de comenzi sau alte caractere, care vor genera erori);
  fluxul de iesire va fi simluat printr-un string ce va contine caracterele
 scrise la executarea fiecarei comenzi;
  de exemplu daca stringul de intrare contine: "assaxnyyt"
         atunci stringul de iesire va contine: "+--+e!ee"

 programul este urmatorul:

.data
  comenzi: .ascii "asnte"
   # vector de byte cu numele comenzilor (doar primele 4 sunt accesibile
   #  utilizatorului);
   # pozitia in vector da codul de identificare 0...4 al comenzii
  t: .word aduna, scade, neaga, termina, eroare
   # tabel de salt (pe pozitia i (0...4) este adresa procedurii ce realizeaza
   #  comanda cu codul i)
  intrare: .ascii "assaxnyyt" # fluxul de intrare
  iesire: .space 100          # fluxul de iesire
.text
main:
  la $s0,intrare # cu $s0 parcurg sirul "intrare"
  la $s1,iesire  # cu $s1 parcurg sirul "iesire"
  get_comanda:
    lb $t0,0($s0)   # $t0=caracterul curent din fluxul de intrare
    addu $s0,1
    la $t1,comenzi  # $t1 va parcurge stringul "comenzi" de la poz. lui "a"
    addiu $t2,$t1,4 #  la cea a lui "e" (stocata in $t2)
   et1:
    lb $t3,0($t1)   # caut $t0 in "comenzi" (pana il gasesc sau pana $t1
    beq $t0,$t3,et2 #  indica comanda de eroare)
    addu $t1,1      #
    bne $t1,$t2,et1 #
   et2:
   sub $t1,$t1,$t2
   addu $t1,4       # acum $t1 este poz. (idf. numeric al) comenzii (4=err)
   sll $t1,$t1,2
   la $t2,t
   addu $t2,$t2,$t1
   lw $t2,0($t2)    # acum $t2 este adr. de mem. a proc. corespunzatoare
   la $ra,get_comanda
   jr $t2
##### proceduri de implementare a comenzilor: #####
aduna:          # la intrare $ra contine adr. lui "get_comanda"
  li $t0,'+'
  sb $t0,0($s1)
  addu $s1,1
  jr $ra        # transfera executia la "get_comanda"
scade:
  li $t0,'-'
  sb $t0,0($s1)
  addu $s1,1
  jr $ra
neaga:
  li $t0,'!'
  sb $t0,0($s1)
  addu $s1,1
  jr $ra
termina:
   # adaos penrtu a afisa sirul "iesire"
  sb $zero,0($s1)
  li $v0,4
  la $a0,iesire
  syscall
   # terminarea programului
  li $v0,10
  syscall
eroare:
  li $t0,'e'
  sb $t0,0($s1)
  addu $s1,1
  jr $ra
#####

Comentarii:
- vectorul de byte "comenzi" este ".ascii" si nu ".asciiz" deoarece logica
 programului garanteaza ca intotdeauna ne vom opri cel tarziu la a 5-a
 componenta, deci nu e nevoie sa marcam sfarsitul cu un terminator nul;
 vectorul de byte "intrare" este tot ".ascii" (si nu ".asciiz") deoarece
 logica programului face ca parcurgerea acestuia sa se termine la intalnirea
 lui "t", deci iarasi n-avem nevoie de terminatorul nul;
- am parcurs sirurile "intrare", "iesire" cu doi registri $s ($s0, resp. $s1)
 deoarece ei trebuie sa-si conserve valoarea curenta peste apelurile
 declansate cu "", iar acest lucru este asigurat de faptul ca registrii $s
 sunt callee-saved;
- observam ca programul apeleaza proceduri si revine din ele fara sa
 foloseasca instructiuni de tip "jal" (adica apel), ci doar "jr" (adica
 return);
- desi scopul comenzii "termina" este doar terminarea programului, in
 implementarea ei am adaugat si o parte pentru afisarea pe consola a sirului
 "iesire" rezultat, deoarece in fereastra "Data Segment" a lui PCSpim vedem
 doar codurile hexa ale caracterelor;
- putem realiza in acelasi mod un interpretor care sa execute comenzi avand
 nume mai lungi de un caracter si avand parametri (vezi exercitiile de la
 sfarsit).

4)
program care afisaza valorile distincte dintr-un vector de intregi:
~~~~~~~~

Translatam urmatorul program C:

  #include<stdio.h>
  void distinct(int *v, int n){
    int d[n]; /* var. loc. auto, se aloca pe stiva de dim. n (dat ca par.) */
    register int i,j,k;
    k=0;
    for(i=0;i<n;++i){
      for(j=0;j<k;++j) if(v[i]==d[j]) break;
      if(j==k) {d[k]=v[i]; ++k;}
    }
    for(i=0;i<k;++i) printf("%d ",d[i]);
    printf("\n");
  }

  int w[]={1,2,5,2,5,1,2,4};

  void main(){
    distinct(w,8); /* afisaza: 1 2 5 4 */
  }

Translatarea este:

.data
  w: .word 1,2,5,2,5,1,2,4
.text
main:
  subu $sp,8
  li $t0,8
  sw $t0,4($sp)
  la $t0,w
  sw $t0,0($sp)  # $sp:(adr.w)(8)
  jal distinct
  addu $sp,8
li $v0,10
syscall
distinct: # primeste: $sp:(v)(n)
    # calculam dimensiunea cadrului de apel
    # pt. asta, accesam par. cu $sp si nu folosim registri callee-saved
  lw $t0,4($sp) # $t0=n
  sll $t0,$t0,2 # $t0=4*n
  addu $t0,20   # $t0=4*n+20 (dim. cadrului de apel)
    # construim cadrul si salvam in el si dimensiunea lui
  sw $t0,-20($sp)   # (dim.cadru)()()()()$sp:(v)(n)
  sw $fp,-4($sp)    # (dim.cadru)()()()($fp v)$sp:(v)(n)
  subu $fp,$sp,4    # (dim.cadru)()()()$fp:($fp v)$sp:(v)(n)
  subu $sp,$sp,$t0  # $sp:()...()(dim.cadru)()()()$fp:($fp v)(v)(n)
  sw $s0,-4($fp)
  sw $s1,-8($fp)
  sw $s2,-12($fp)
    # restul cadrului de apel este d[0] ... d[n-1], deci avem:
    # $sp:(d[0])...(d[n-1])(dim.cadru)($s2 v)($s1 v)($s0 v)$fp:($fp v)(v)(n)
    # convenim sa alocam i in $s0, j in $s1, k in $s2
  li $s2,0      # k=0
  li $s0,0      # i=0
  distinct_ciclu1_inceput:
  lw $t0,8($fp) # $t0=n
  bge $s0,$t0,distinct_ciclu1_sfarsit
    li $s1,0      # j=0
    distinct_ciclu2_inceput:
    bge $s1,$s2,distinct_ciclu2_sfarsit
      lw $t0,4($fp)    # $t0=v
      move $t2,$s0     # $t2=i
      sll $t2,$t2,2    # $t2=i*4
      add $t0,$t0,$t2  # $t0=(unsigned char *)v+i*4=v+i
      lw $t0,0($t0)    # $t0=*(v+i)=v[i]
      lw $t1,-16($fp)  # $t1=dim.cadru
      subu $t1,4
      subu $t1,$fp,$t1 # $t1=d
      move $t2,$s1     # $t2=j
      sll $t2,$t2,2    # $t2=j*4
      add $t1,$t1,$t2  # $t1=(unsigned char *)d+j*4=d+j
      lw $t1,0($t1)    # $t1=*(d+j)=d[j]
      beq $t0,$t1,distinct_ciclu2_sfarsit # if(v[i]==d[j]) break;
    add $s1,1     # ++j
    b distinct_ciclu2_inceput
    distinct_ciclu2_sfarsit:
    beq $s1,$s2,distinct_et1 # if(j==k)...
    b distinct_et2
    distinct_et1:            # ...then
      lw $t0,4($fp)    # $t0=v
      move $t2,$s0     # $t2=i
      sll $t2,$t2,2    # $t2=i*4
      add $t0,$t0,$t2  # $t0=(unsigned char *)v+i*4=v+i
      lw $t0,0($t0)    # $t0=*(v+i)=v[i]
      lw $t1,-16($fp)  # $t1=dim.cadru
      subu $t1,4
      subu $t1,$fp,$t1 # $t1=d
      move $t2,$s2     # $t2=k
      sll $t2,$t2,2    # $t2=k*4
      add $t1,$t1,$t2  # $t1=(unsigned char *)d+k*4=d+k
      sw $t0,0($t1)    # *(d+k)=v[i], adica d[k]=v[i];
      add $s2,1        # ++k
    distinct_et2:
  add $s0,1     # ++i
  b distinct_ciclu1_inceput
  distinct_ciclu1_sfarsit:
    # afisare
  li $s0,0      # i=0
  distinct_ciclu3_inceput:
  bge $s0,$s2,distinct_ciclu3_sfarsit
    li $v0,1  # print int
    lw $t0,-16($fp)  # $t0=dim.cadru
    subu $t0,4
    subu $t0,$fp,$t0 # $t0=d
    move $t2,$s0     # $t2=i
    sll $t2,$t2,2    # $t2=i*4
    add $t0,$t0,$t2  # $t1=(unsigned char *)d+i*4=d+i
    lw $a0,0($t0)    # $t0=*(d+i)=d[i]
    syscall
    li $v0,4  # print string
    la $a0,distinct_blank
    syscall
  add $s0,1     # ++i
  b distinct_ciclu3_inceput
  distinct_ciclu3_sfarsit:
    li $v0,4  # print string
    la $a0,distinct_newline
    syscall
    # iesirea din apel
  lw $s0,-4($fp)   # restauram $s0
  lw $s1,-8($fp)   # restauram $s1
  lw $s2,-12($fp)  # restauram $s2
  lw $t0,-16($fp)  # $t0=dim.cadru
  lw $fp,0($fp)    # restauram $fp
  addu $sp,$sp,$t0 # eliminam cadrul de apel
jr $ra
.data
  distinct_blank: .asciiz " "
  distinct_newline: .asciiz "\n"
##########

 Constatam ca in implementarea de mai sus fiecare accesare a lui "d" necesita
un calcul prealabil al adresei de inceput a acestuia; in acest scop a trebuit
sa salvam in stiva dimensiunea cadrului de apel (aceasta ne-a folosit si la
sfarsit, ca sa eliminam cadrul de apel).
 Putem lucra mai eficient daca salvam in stiva direct adresa de inceput a
lui "d"; mai general, daca avem de alocat in cadrul de apel mai multe
entitati automatice de dimensiune variabila (asemeni lui "d") vom calcula o
singura data la inceputul apelului adresele lor si le vom stoca in cadru
imediat sub entitatile de dimensiune constanta - ele vor putea fi gasite
folosind offset-uri constante fata de $fp, cunoscute in faza de elaborare a
programului; dimensiunea cadrului de apel nu este necesar sa o salvam in
stiva, deoarece daca stim ca $fp pointeaza primul word din cadru putem
elimina cadrul atribuind lui $sp valoarea $fp+4.
 Cu aceste modificari procedura devine:

distinct: # primeste: $sp:(v)(n)
    # construim partea de dimensiune fixa a cadrului de apel
    #  continand $fp, $s0, $s1, $s2 salvati si locatia de salvare a adr. "d"
  subu $sp,20
  sw $fp,16($sp)
  sw $s0,12($sp)
  sw $s1,8($sp)
  sw $s2,4($sp)
  addiu $fp,$sp,16
    # acum $sp:()($s2 v)($s1 v)($s0 v)$fp($fp v)(v)(n)
    # calculam adr. de inceput a lui "d" si o salvam in cadru la -16($fp),
    #  apoi alocam "d" mutand $sp la adr. respectiva
  lw $t0,8($fp)    # $t0=n
  sll $t0,$t0,2    # $t0=4*n
  addiu $t0,$t0,16 # $t0=4*n+16
  subu $t0,$fp,$t0 # $t0=$fp-4*n-16=adr.lui "d"
  sw $t0,-16($fp)  # salvam adr. lui "d" in cadru
  move $sp,$t0     # alocam "d"
    # acum $sp:(d[0])...(d[n-1])(adr.d)($s2 v)($s1 v)($s0 v)$fp($fp v)(v)(n)
    # ca inainte, convenim sa alocam i in $s0, j in $s1, k in $s2
  li $s2,0      # k=0
  li $s0,0      # i=0
  distinct_ciclu1_inceput:
  lw $t0,8($fp) # $t0=n
  bge $s0,$t0,distinct_ciclu1_sfarsit
    li $s1,0      # j=0
    distinct_ciclu2_inceput:
    bge $s1,$s2,distinct_ciclu2_sfarsit
      lw $t0,4($fp)    # $t0=v
      move $t2,$s0     # $t2=i
      sll $t2,$t2,2    # $t2=i*4
      add $t0,$t0,$t2  # $t0=(unsigned char *)v+i*4=v+i
      lw $t0,0($t0)    # $t0=*(v+i)=v[i]
      lw $t1,-16($fp)  # $t1=d
      move $t2,$s1     # $t2=j
      sll $t2,$t2,2    # $t2=j*4
      add $t1,$t1,$t2  # $t1=(unsigned char *)d+j*4=d+j
      lw $t1,0($t1)    # $t1=*(d+j)=d[j]
      beq $t0,$t1,distinct_ciclu2_sfarsit # if(v[i]==d[j]) break;
    add $s1,1     # ++j
    b distinct_ciclu2_inceput
    distinct_ciclu2_sfarsit:
    beq $s1,$s2,distinct_et1 # if(j==k)...
    b distinct_et2
    distinct_et1:            # ...then
      lw $t0,4($fp)    # $t0=v
      move $t2,$s0     # $t2=i
      sll $t2,$t2,2    # $t2=i*4
      add $t0,$t0,$t2  # $t0=(unsigned char *)v+i*4=v+i
      lw $t0,0($t0)    # $t0=*(v+i)=v[i]
      lw $t1,-16($fp)  # $t1=d
      move $t2,$s2     # $t2=k
      sll $t2,$t2,2    # $t2=k*4
      add $t1,$t1,$t2  # $t1=(unsigned char *)d+k*4=d+k
      sw $t0,0($t1)    # *(d+k)=v[i], adica d[k]=v[i];
      add $s2,1        # ++k
    distinct_et2:
  add $s0,1     # ++i
  b distinct_ciclu1_inceput
  distinct_ciclu1_sfarsit:
    # afisare
  li $s0,0      # i=0
  distinct_ciclu3_inceput:
  bge $s0,$s2,distinct_ciclu3_sfarsit
    li $v0,1  # print int
    lw $t0,-16($fp)  # $t0=d
    move $t2,$s0     # $t2=i
    sll $t2,$t2,2    # $t2=i*4
    add $t0,$t0,$t2  # $t1=(unsigned char *)d+i*4=d+i
    lw $a0,0($t0)    # $t0=*(d+i)=d[i]
    syscall
    li $v0,4  # print string
    la $a0,distinct_blank
    syscall
  add $s0,1     # ++i
  b distinct_ciclu3_inceput
  distinct_ciclu3_sfarsit:
    li $v0,4  # print string
    la $a0,distinct_newline
    syscall
    # iesirea din apel
  lw $s0,-4($fp)   # restauram $s0
  lw $s1,-8($fp)   # restauram $s1
  lw $s2,-12($fp)  # restauram $s2
  addiu $sp,$fp,4  # plasam $sp (practic eliminam cadrul)
  lw $fp,0($fp)    # restauram $fp ($fp vechi inca se poate accesa cu 0($fp))
jr $ra
.data
  distinct_blank: .asciiz " "
  distinct_newline: .asciiz "\n"
##########


5)citirea unui vector de intregi, intregii fiind introdusi de la consola in format hexa. Functiile vor returna prin registrii.

Translatam urmatorul program C:

#include<stdio.h>

int getinthexa(){
  char buf[11];      /* vector local automatic de dim. fixa */
  register int i,n;  /* variabile locale register */
  scanf("%s",buf);   /* sau: fflush(stdin); gets(buf); */
  n=0;
  for(i=2;i<10;++i){
    n=n*16+buf[i]-'0';
    if(buf[i]>='a')n=n-39; /* 39=('a'-'0')-10 */
  }
  return n;
}

int v[10];           /* vector global */

int main(){
  int n;             /* variabila locala automatica */
  register int i;    /* variabila locala register */
  scanf("%d",&n);
  for(i=0;i<n;++i){
    v[i]=getinthexa();
  }
  for(i=0;i<n;++i) printf("%d ",v[i]);
  printf("\n");
  return 0;
}

/* daca tastam:
     2
     0x0000001a
     0x00000102
   atunci se va afisa:
     26 258
*/

Translatarea este:

.data
  v: .space 40
  blank: .asciiz " "
  nl: .asciiz "\n"
.text
main:
    # "main" e o functie ce necesita un cadru de apel
    #   in care alocam "n" si salvam $s0 (va fi "i"), $fp;
    # functia "main" returneaza 0 prin $v0
  subu $sp,12
  sw $fp,8($sp)
  sw $s0,4($sp)
  addiu $fp,$sp,8
    # $sp:(n)($s0 v)$fp:($fp v)
  li $v0,5       # read int
  syscall
  sw $v0,-8($fp) # scanf("%d",&n)
  li $s0,0       # i=0
  main_ciclu1_inceput:
  lw $t0,-8($fp) # $t0=n
  bge $s0,$t0,main_ciclu1_sfarsit
    jal getinthexa  # functie fara parametri, cu retur prin $v0
    la $t0,v        # $t0=v
    move $t1,$s0    # $t1=i
    sll $t1,$t1,2   # $t1=4*i
    add $t0,$t0,$t1 # $t0=(unsigned char *)v+4*i=v+i
    sw $v0,0($t0)   # v[i]=getinthexa();
  add $s0,1  # ++i
  b main_ciclu1_inceput
  main_ciclu1_sfarsit:
  li $s0,0       # i=0
  main_ciclu2_inceput:
  lw $t0,-8($fp) # $t0=n
  bge $s0,$t0,main_ciclu2_sfarsit
    li $v0,1        # print int
    move $t0,$s0    # $t0=i
    sll $t0,$t0,2   # $t0=4*i
    la $a0,v
    add $a0,$a0,$t0 # $a0=(unsigned char *)v+4*i=v+i
    lw $a0,0($a0)   # $a0=v[i]
    syscall
    li $v0,4        # print string
    la $a0,blank
    syscall
  add $s0,1  # ++i
  b main_ciclu2_inceput
  main_ciclu2_sfarsit:
  li $v0,4        # print string
  la $a0,nl
  syscall
    # iesirea din "main"
  li $v0,0       # "main" returneaza 0
  lw $s0,-4($fp) # restauram $s0
  lw $fp,0($fp)  # restauram $fp
  addu $sp,12    # eliminam cadrul de apel
jr $ra           # revenim la kernel (care a lansat programul cu "jal main")
getinthexa:
    # "getinthexa" e o functie ce necesita un cadru de apel
    #   in care alocam "buf" si salvam $fp, $s0 (va fi "i"), $s1 (va fi "n");
    # "buf" are dim. constanta (11 bytes pe care il vom aproxima prin 12
    #   bytes ca sa avem adrese aliniate), deci cadrul are dim. constanta
    #   (anume 4+4+4+12=24 bytes), nu ca in exemplul anterior
  subu $sp,24
  sw $fp,20($sp)
  sw $s0,16($sp)
  sw $s1,12($sp)
  addiu $fp,$sp,20
    # $sp:(buf[0]...buf[3])(buf[4]...buf[7])(buf[8]...buf[10],.)
    #        ($s1 v)($s0 v)$fp:($fp v)
  li $v0,8        # read string
  subu $a0,$fp,20 # $a0=buf
  li $a1,11       # lungimea maxima a sirului citit
  syscall         # gets(buf)
  li $s1,0        # n=0;
  li $s0,2        # i=2
  getinthexa_ciclu_inceput:
  li $t0,10
  bge $s0,$t0,getinthexa_ciclu_sfarsit
    subu $t0,$fp,20 # $t0=buf
    add $t0,$t0,$s0 # $t0=buf+i ("buf" are componente de 1 byte, nu 1 word)
    lb $t0,0($t0)   # $t0=buf[i] (byte)
    sub $t1,$t0,'0' # $t1=buf[i]-'0'
    li $t2,'a'
    blt $t0,$t2,getinthexa_et
      sub $t1,39    # if(buf[i]>='a') $t1=(buf[i]-'0')-39
    getinthexa_et:
    sll $s1,$s1,4   # n=n*16
    add $s1,$s1,$t1 # n=n*16+buf[i]-'0' sau n=n*16+(buf[i]-'0')-39
  add $s0,1       # ++i
  b getinthexa_ciclu_inceput
  getinthexa_ciclu_sfarsit:
    # iesirea din "getinthexa"
  move $v0,$s1    # valoarea returnata "n"
  lw $s0,-4($fp)
  lw $s1,-8($fp)
  lw $fp,0($fp)
  addu $sp,24
jr $ra
##########

Comentarii:
- programul MIPS de mai sus nu ruleaza corect pe PCSpim din cauza unor
 probleme legate de citirea de la consola; cel mai bine se poate urmari
 ruland pas cu pas (cu F10);
- intrucat vectorul local automatic "buf" are dimensiune fixa (anume 10
 bytes) alocarea lui se face obisnuit iar cadrul de apel are dimensiune fixa
 24 bytes (cunoscuta in faza de elaborare a programului), nu ca in exemplul
 anterior; pentru asemenea vectori, calculul adresei unei componente se poate
 face mai usor; nu s-a putut vedea asta in programul nostru deoarece "buf"
 era vector de byte, dar daca era vector de word operatia "$t0=buf[i]" se
 putea transcrie:

   move $t0,$s0    # $t0=i
   sll $t0,$t0,2   # $t0=4*i
   add $t0,$t0,$fp
   sub $t0,$t0,20  # $t0=4*i+$fp-20=(unsigned char *)buf+4*i=buf+i
   lw $t0,0($t0)   # $t0=buf[i]

 spre deosebire de operatia "$a0=v[i]" (unde se acceseaza un vector global)
 din "main" care necestia doi registri (nu putem folosi doar $a0):

   move $t0,$s0      # $t0=i
   sll $t0,$t0,2   # $t0=4*i
   la $a0,v
   add $a0,$a0,$t0 # $a0=(unsigned char *)v+4*i=v+i
   lw $a0,0($a0)   # $a0=v[i]


6)Backtracking recursiv folosind un vector local static;
programul genereaza permutarile de ordin n.

Translatam urmatorul program C:

#include<stdio.h>

void gen(int n){
 static int v[10],k=0;
 register int i,j;
 if(k==n){
   for(i=0;i<n;++i)printf("%d ",v[i]);
   printf("\n");
 }
 for(i=1;i<=n;++i){
   for(j=0;j<k;++j)if(v[j]==i)break;
   if(j==k){v[k]=i; ++k; gen(n); --k;}
 }
}

void main(){
  int n;
  scanf("%d",&n);
  gen(n);
}

/* pe consola vedem (primul 3 e tastat de noi):
   3
   1 2 3
   1 3 2
   2 1 3
   2 3 1
   3 1 2
   3 2 1
*/

Translatarea este:

.data
  n: .space 4
.text
main:
    # citire "n"
  li $v0,5
  syscall
  sw $v0,n
    # apel "gen(n)"
  subu $sp,4
  lw $t0,n
  sw $t0,0($sp)
  jal gen
  addu $sp,4
li $v0,10
syscall
.data
  v: .space 40 # "v" desi local, se aloca static
  k: .word 0   # "k" e local static si se init. o data, inaintea apelurilor
  blank: .asciiz " "
  nl: .asciiz "\n"
.text
gen:
  subu $sp,16
  sw $ra,12($sp)
  sw $fp,8($sp)
  sw $s0,4($sp)
  sw $s1,0($sp)
  addiu $fp,$sp,12
    # $sp:($s1 v)($s0 v)($fp v)$fp:($ra v)(n)
    # convin ca $s0=i, $s1=j
  lw $t0,k
  lw $t1,4($fp)       # $t1=n
  bne $t0,$t1,gen_et1 # test k!=n
    li $s0,0            # i=0
    gen_et2:
    lw $t1,4($fp)       # $t1=n
    bge $s0,$t1,gen_et3 # test i>=n
      li $v0,1          # print int
      la $a0,v
      move $t0,$s0
      sll $t0,$t0,2
      add $a0,$a0,$t0
      lw $a0,0($a0)     # $a0=v[i]
      syscall
      li $v0,4          # print string
      la $a0,blank
      syscall
    add $s0,1           # ++i
    b gen_et2
    gen_et3:
    li $v0,4  # print string
    la $a0,nl
    syscall
  gen_et1:
  li $s0,1             # i=1
  gen_et4:
  lw $t1,4($fp)        # $t1=n
  bgt $s0,$t1,gen_et5  # test i>n
    li $s1,0             # j=0
    lw $t2,k             # $t2=k
    la $t3,v             # $t3=adr.lui v
    gen_et6:
    bge $s1,$t2,gen_et7  # test j>=k
      move $t0,$s1
      sll $t0,$t0,2
      add $t0,$t0,$t3
      lw $t0,0($t0)        # $t0=v[j]
      beq $t0,$s0,gen_et7  # if(v[j]==i)break;
    add $s1,1            # ++j
    b gen_et6
    gen_et7:
    bne $s1,$t2,gen_et8  # test j!=k ($t2 inca contine k)
      move $t0,$t2    # $t0=k
      sll $t0,$t0,2   # $t0=4*k
      add $t0,$t0,$t3 # $t0=(unsigned char*)v+4*k=v+k ($t3 inca contine v)
      sw $s0,0($t0)   # v[k]=i
      add $t2,1
      sw $t2,k        # ++k
      subu $sp,4
      lw $t0,4($fp)
      sw $t0,0($sp)   # push n
      jal gen         # gen(n) (apelul imbricat)
      addu $sp,4
      lw $t2,k
      sub $t2,1
      sw $t2,k        # --k
      lw $t3,v        # acum $t2, $t3 iar contin k, resp. v
    gen_et8:
  add $s0,1            # ++i
  b gen_et4
  gen_et5:
  lw $s1,-12($fp)
  lw $s0,-8($fp)
  lw $ra,0($fp)
  lw $fp,-4($fp)
  addu $sp,16
jr $ra
##########

Comentarii:
- "v" si "k" sunt locale lui "gen" (pot fi accesate doar din "gen") dar sunt
 statice (deci se aloca in zona de date statice si isi pastreaza locatia pe
 toata perioada executarii programului); astfel o valoare lasata de un apel
 al lui "gen" in "v" sau "k" va fi regasita de apelul urmator (deci
 variabilele locale statice sunt un mijloc de comunicare intre apelurile
 succesive ale procedurii); in plus initializarea "k=0" are loc o singura
 data, inaintea primului apel al lui "gen" (nu la fiecare nou apel);
- desi la prima intalnire a lui "gen_et2:" $t1 contine deja "n", l-am
 reincarcat cu "lw $t1,4($fp)" deoarece aici ajungem si dupa ce s-au facut
 iteratii, iar in iteratii facem "syscall" care ar putea altera $t1 (nu e
 callee-saved); la fel am procedat si la "gen_et4:"; de asemenea, $t2 si $t3
 incarcate inainte de "gen_et6:" cu "k", respectiv adresa lui "v" isi
 pastreaza valoare (deoarece nu facem apeluri imbricate sau "syscall") pana
 la apelul imbricat "gen(n)", deci nu mai trebuie reincarcati la fiecare
 calcul "v[i]" sau "v[k]"; cand facem "++k" sau "--k" in preajma apelului
 imbricat "gen(n)" ei trebuie reincarcati, inclusiv "k" trebuie salvat in
 memorie, deoarece $t2, $t3 nu sunt callee-saved.


7)Parametri (pointeri la) functii;
programul reprezinta grafic (in mod text) niste functii reale de
variabila reala, folosind o procedura care primeste adresele lor
ca parametri.

Translatam urmatorul program C:

#include<stdio.h>

void reprezinta(double (*f)(double),double a,double b,double dx,double dy){
  char linie[42];
  register int i,k; register char c; register double x,y;
  for(x=a;x<=b;x+=dx){
    y=(*f)(x); k=(int)(y/dy)+20;
    if(0<=x && x<dx)c='-'; else c=' ';
    for(i=0;i<=40;++i)linie[i]=c;
    linie[20]='|';
    if(0<=k && k<=40)linie[k]='*';
    linie[41]='\0';
    printf("%s\n",linie);
  }
}

double sin(double x) /* aproximeaza sin(x) */
 {return x-x*x*x/6+x*x*x*x*x/120-x*x*x*x*x*x*x/5040;}

double parabola(double x) /* o parabola */
 {return 0.3*x*x-0.3*x-0.7;}

double dreapta(double x) /* o dreapta */
 {return x-1;}

double (*vect_f[])(double)= {sin, parabola, dreapta};
double vect_a[]= {  -3,  -2,  -1};
double vect_b[]= {   3,   3,   2};
double vect_dx[]={ 0.3, 0.3, 0.3};
double vect_dy[]={ 0.1, 0.1, 0.1};
int n=3;

void main(){
  register int i;
  for(i=0;i<n;++i){
    reprezinta(vect_f[i],vect_a[i],vect_b[i],vect_dx[i],vect_dy[i]);
    printf("\n");
  }
}

/* afisaza:
                    *
                *   |
              *     |
            *       |
           *        |
           *        |
           *        |
             *      |
               *    |
                  * |
                    *
--------------------|-*------------------
                    |    *
                    |      *
                    |        *
                    |        *
                    |        *
                    |       *
                    |     *
                    |   *
                    *

                    |          *
                    |     *
                    |  *
                    *
                  * |
                *   |
              *     |
-------------*------|--------------------
             *      |
             *      |
              *     |
               *    |
                *   |
                   *|
                    *
                    |   *
                    |       *

 *                  |
    *               |
       *            |
         *          |
------------*-------|--------------------
                *   |
                   *|
                    |*
                    |   *
                    |      *
                    |        *
*/

Translatarea este:

.data
  vect_f: .word sin, parabola, dreapta
  vect_a: .double -3.0, -2.0, -1.0
  vect_b: .double  3.0,  3.0,  2.0
  vect_dx:.double  0.3,  0.3,  0.3
  vect_dy:.double  0.1,  0.1,  0.1
  n: .word 3
  nl: .asciiz "\n"
.text
##### programul principal
main:
  li $s0,0             # i=0
  main_et1:
  lw $t0,n
  bge $s0,$t0,main_et2 # test i>=n
    sll $t0,$s0,2  # $t0=4*i
    sll $t1,$s0,3  # $t1=8*i
    subu $sp,40
    la $t2,vect_dy
    add $t2,$t2,$t1
    l.d $f0,0($t2) # $f0=vect_dy[i]
    s.d $f0,32($sp)# push vect_dy[i]
    la $t2,vect_dx
    add $t2,$t2,$t1
    l.d $f0,0($t2) # $f0=vect_dx[i]
    s.d $f0,24($sp)# push vect_dx[i]
    la $t2,vect_b
    add $t2,$t2,$t1
    l.d $f0,0($t2) # $f0=vect_b[i]
    s.d $f0,16($sp)# push vect_b[i]
    la $t2,vect_a
    add $t2,$t2,$t1
    l.d $f0,0($t2) # $f0=vect_a[i]
    s.d $f0,8($sp) # push vect_a[i]
    la $t2,vect_f
    add $t2,$t2,$t0
    lw $t3,0($t2) # $f0=vect_f[i]
    sw $t3,0($sp) # push vect_f[i]
    jal reprezinta
    addu $sp,40
    li $v0,4  # print string
    la $a0,nl
    syscall   # printf("\n");
  add $s0,1            # ++i
  b main_et1
  main_et2:
li $v0,10
syscall
##### procedura "reprezinta"
reprezinta:
# primeste: $sp:(f (pointer))()[a][b][dx][dy]
# unde () inseamna un word iar [] inseamna un dublu word
  subu $sp,88
  sw $ra,84($sp)
  sw $fp,80($sp)
  s.d $f0,72($sp) # $f0 va fi x (adresa este multiplu de 8)
  s.d $f2,64($sp) # $f2 va fi un reg. auxiliar (adresa este multiplu de 8)
  s.d $f4,56($sp) # $f4 va fi un reg. auxiliar (adresa este multiplu de 8)
  sw $s2,52($sp)  # $s2 va fi c
  sw $s1,48($sp)  # $s1 va fi k
  sw $s0,44($sp)  # $s0 va fi i
  addiu $fp,$sp,84
    # $sp:(linie[0]...linie[3])...(linie[40],linie[41],.,.)
    #        ($s0 v)($s1 v)($s2 v)[$f4 v][$f2 v][$f0 v]($fp v)$fp:($ra v)
    #        (f)()[a][b][dx][dy]
  l.d $f0,12($fp)     # x=a
  reprezinta_et1:
  l.d $f2,20($fp)     # $f2=b
  c.lt.d $f2,$f0      # daca x>b, flag-ul 0 al coprocesorului 1 devine 1
  bc1t reprezinta_et2 # daca flag-ul 0 al coprocesorului 1 este 1, salt
    subu $sp,8
    s.d $f0,0($sp)     # push x
    lw $t0,4($fp)      # $t0=f
    jalr $ra,$t0       # apel (*f)(x) (returneaza un double prin stiva)
    l.d $f2,0($sp)     # $f2=(*f)(x)=y
    addu $sp,8
    l.d $f4,36($fp)    # $f4=dy
    div.d $f2,$f2,$f4  # $f2=y/dy
    cvt.w.d $f4,$f2    # $f4=(int)(y/dy), codificat ca int (!)
    mfc1.d $t0,$f4     # copiaza config. din ($f4,$f5) in ($t0,$t1)
    move $s1,$t0       # k=(int)(y/dy) (eventual trunchiat)
    li $t0,20
    add $s1,$s1,20     # k=(int)(y/dy)+20
    li $t0,0           # $t0=false
    li $t2,1           # $t2=true
    li.d $f2,0.0       # $f2=0
    c.le.d $f2,$f0     # flag-ul 0 al cop. 1 devine 1 daca 0<=x, si 0 altfel
    mtc1.d $t0,$f2     # $f2=false
    mtc1.d $t2,$f4     # $f4=true
    movt.d $f2,$f4,0   # daca flag-ul 0 e 1, $f2 ia val. $f4, adica true
    mfc1.d $t4,$f2     # $t4=val. de adevar a lui "0<=x"
    l.d $f2,28($fp)    # $f2=dx
    c.le.d $f0,$f2     # flag-ul 0 al cop. 1 devine 1 daca x<=dx,si 0 altfel
    mtc1.d $t0,$f2     # $f2=false
    mtc1.d $t2,$f4     # $f4=true
    movt.d $f2,$f4,0   # daca flag-ul 0 e 1, $f2 ia val. $f4, adica true
    mfc1.d $t6,$f2     # $t6=val. de adevar a lui "x<=dx"
    and $t4,$t4,$t6    # $t4=val. de adevar a lui "0<=x && x<=dx"
    li $s2,'-'         # c='-'
    bnez $t4,reprezinta_et3 # daca "0<=x && x<=dx" e adev. "c" ramane '-'
    li $s2,' '
    reprezinta_et3:
    li $s0,0                    # i=0
    reprezinta_et4:
    li $t0,40
    bgt $s0,$t0,reprezinta_et5  # test i>40
      addiu $t0,$fp,-84  # $t0=adr.lui "linie"
      add $t0,$t0,$s0    # $t0=adr.lui "linie[i]" (e byte, nu trebuie *4)
      sb $s2,0($t0)      # linie[i]=c
    add $s0,1
    b reprezinta_et4
    reprezinta_et5:
    addiu $t0,$fp,-84  # $t0=adr.lui "linie"
    addiu $t0,$t0,20   # $t0=adr.lui "linie[20]"
    li $t1,'|'
    sb $t1,0($t0)      # linie[20]='|'
    sle $t0,$zero,$s1  # $t0 = (0<=k)
    li $t1,40
    sle $t1,$s1,$t1    # $t1 = (k<=40)
    and $t0,$t0,$t1    # $t0 = (0<=k && k<=40)
    beqz $t0,reprezinta_et6 # daca 0<=k && k<=40 e fals, nu pun "*"
      li $t1,'*'
      addiu $t0,$fp,-84  # $t0=adr.lui "linie"
      add $t0,$t0,$s1    # $t0=adr.lui "linie[k]"
      sb $t1,0($t0)      # linie[k]='*'
    reprezinta_et6:
    addiu $t0,$fp,-84  # $t0=adr.lui "linie"
    addiu $t0,$t0,41   # $t0=adr.lui "linie[41]"
    sb $zero,0($t0)    # linie[41]='\0'
    li $v0,4           # print string
    addiu $a0,$fp,-84  # $a0=adr.lui "linie"
    syscall
    li $v0,4
    la $a0,nl
    syscall
  l.d $f2,28($fp)     # $f2=dx
  add.d $f0,$f0,$f2   # x+=dx
  b reprezinta_et1
  reprezinta_et2:
  l.d $f0,-12($fp)
  l.d $f2,-20($fp)
  l.d $f4,-28($fp)
  lw $s2,-32($fp)
  lw $s1,-36($fp)
  lw $s0,-40($fp)
  lw $ra,0($fp)
  lw $fp,-4($fp)
  addu $sp,88
jr $ra
##### functia "sin"
sin: # primeste $sp:[x] si returneaza prin stiva
  subu $sp,40
  sw $fp,32($sp)
  s.d $f6,24($sp)
  s.d $f4,16($sp)
  s.d $f2,8($sp)
  s.d $f0,0($sp)
  addiu $fp,$sp,36 # $sp:[$f0 v][$f2 v][$f4 v][$f6 v]($fp v)$fp:()[x]
  l.d $f0,4($fp)     # $f0=x
  mov.d $f6,$f0      # $f6=x
  mul.d $f2,$f0,$f0  # $f2=x*x
  mul.d $f2,$f2,$f0  # $f2=x*x*x
  li.d $f4,6.0
  div.d $f4,$f2,$f4  # $f4=x*x*x/6
  sub.d $f6,$f6,$f4  # $f6=x-x*x*x/6
  mul.d $f2,$f2,$f0  # $f2=x*x*x*x
  mul.d $f2,$f2,$f0  # $f2=x*x*x*x*x
  li.d $f4,120.0
  div.d $f4,$f2,$f4  # $f4=x*x*x*x*x/120
  add.d $f6,$f6,$f4  # $f6=x-x*x*x/6+x*x*x*x*x/120
  mul.d $f2,$f2,$f0  # $f2=x*x*x*x*x*x
  mul.d $f2,$f2,$f0  # $f2=x*x*x*x*x*x*x
  li.d $f4,5040.0
  div.d $f4,$f2,$f4  # $f4=x*x*x*x*x*x*x/5040
  sub.d $f6,$f6,$f4  # $f6=x-x*x*x/6+x*x*x*x*x/120+x*x*x*x*x*x*x/5040
  s.d $f6,4($fp)   # $sp:[$f0 v][$f2 v][$f4 v][$f6 v]($fp v)$fp:()[rezultat]
  l.d $f6,-12($fp)
  l.d $f4,-20($fp)
  l.d $f2,-28($fp)
  l.d $f0,-36($fp)
  lw $fp,-4($fp)
  addu $sp,40
jr $ra
##### functia "parabola"
parabola: # primeste $sp:[x] si returneaza prin stiva
  subu $sp,40
  sw $fp,32($sp)
  s.d $f6,24($sp)
  s.d $f4,16($sp)
  s.d $f2,8($sp)
  s.d $f0,0($sp)
  addiu $fp,$sp,36 # $sp:[$f0 v][$f2 v][$f4 v][$f6 v]($fp v)$fp:()[x]
  l.d $f0,4($fp)     # $f0=x
  mul.d $f2,$f0,$f0  # $f2=x*x
  li.d $f4,0.3       # $f4=0.3
  mul.d $f6,$f4,$f2  # $f6=0.3*x*x
  mul.d $f2,$f4,$f0  # $f2=0.3*x
  sub.d $f6,$f6,$f2  # $f6=0.3*x*x-0.3*x
  li.d $f2,0.7
  sub.d $f6,$f6,$f2  # $f6=0.3*x*x-0.3*x-0.7
  s.d $f6,4($fp)   # $sp:[$f0 v][$f2 v][$f4 v][$f6 v]($fp v)$fp:()[rezultat]
  l.d $f6,-12($fp)
  l.d $f4,-20($fp)
  l.d $f2,-28($fp)
  l.d $f0,-36($fp)
  lw $fp,-4($fp)
  addu $sp,40
jr $ra
##### functia "dreapta"
dreapta: # primeste $sp:[x] si returneaza prin stiva
  subu $sp,24
  sw $fp,16($sp)
  s.d $f2,8($sp)
  s.d $f0,0($sp)
  addiu $fp,$sp,20 # $sp:[$f0 v][$f2 v]($fp v)$fp:()[x]
  l.d $f0,4($fp)     # $f0=x
  li.d $f2,1.0
  sub.d $f2,$f0,$f2
  s.d $f2,4($fp)   # $sp:[$f0 v][$f2 v]($fp v)$fp:()[rezultat]
  l.d $f2,-12($fp)
  l.d $f0,-20($fp)
  lw $fp,-4($fp)
  addu $sp,24
jr $ra
##########

Comentarii:
- procedura "reprezinta" reprezinta grafic in mod text, sub forma unui sir
 de "*" pe verticala, desenand si axele de coordonate (Ox pe verticala, Oy
 pe orizontala), o functie reala de variabila reala a carei adresa este
 primita ca parametru; semnificatia parametrilor lui "reprezinta" este:
 "f": adresa functiei reale de variabila reala ce trebuie reprezentata;
 "a", "b": capetele intervalului de definitie a functiei;
 "dx", "dy": scara de reprezentare; practic "dx", "dy" inseamna lungimea
   segmentului pe Ox, resp. Oy, care pe ecran se reprezinta printr-un
   singur caracter;
 procedura construieste graficul linie cu linie in stringul "linie" si
 fiecare linie construita este imediat afisata; fiecare asemenea linie este
 o linie verticala corespunzatoare cate unei valori a lui "x" in intervalul
 ["a","b"]; acest interval este parcurs in pasi de lungime "dx" (ei
 corespund unui salt de un caracter pe ecran); intrucat graficul este
 desenat pe verticala, liniile verticale construite succesiv sunt afisate
 orizontal (cu "printf("%s\n",linie)");
  "y" este imaginea lui "x" in multimea numerelor reale iar "k"
 corespondentul lui "y" pe ecran, in numar de caractere fata de caracterul
 origine;
  cel mult una din liniile afisate poate contine axa Oy; acest lucru este
 detectat cu conditia "0<=x && x<dx"; la jumatatea fiecarei linii trebuie
 desenata intersectia cu Ox, sub forma unui '|';
- in programul C, pe langa procedura "reprezinta", am definit un vector de
 pointeri la functii (ce primesc un parametru double si returneaza double)
 "vect_f" si niste vectori de double "vect_a","vect_b","vect_dx","vect_dy",
 pe care i-am initializat cu adresele unor functii "sin", "parabola",
 "dreapta" si niste valori a, b, dx, dy potrivite pentru fiecare; in "main"
 am aplicat "reprezinta" pentru fiecare asemenea sistem;
- in programul MIPS am tinut cont ca pointerii sunt pe 4 octeti iar valorile
 double pe 8 octeti - asta a influentat de ex. regula de calculare a
 offset-urilor componentelor vectorilor de pointeri si double si spatiul
 alocat in stiva pentru ele;
  de asemenea, intrucat in stiva se salveaza si valori double (parametri,
 registrii $f0, $f2 salvati/restaurati) iar acestea nu se pot scrie/citi
 decat la adrese multiplu de 8 (dimensiunea tipului double), am avut grija
 ca $sp sa ia doar valori multiplu de 8; de aceea in "main" am push-at
 parametrul "vect_f[i]" tot pe 8 octeti, desi valoarea lui are doar 4
 octeti; puteam sa nu constrang $sp sa varieze din 8 in 8, dar atunci
 trebuia sa calculez si sa aloc spatii suplimentare la scrierea in stiva
 a fiecarui double;
- functiile "sin", "parabola", "dreapta" au fost implementate sa returneze
 prin stiva;
- pentru instructiunile in virgula mobila a se (re)vedea lectia 2;
 notam ca flag-ul 0 al coprocesorului 1 setat cu "c.lt.d", "c.le.d",etc. isi
 pastreaza valoarea pana se executa o alta instructiune de acest tip (adica
 despre care am specificat in lectia 2 ca modifica flag-ul);
- pentru evaluarea expresiei "0<=x && x<=dx" am fi avut nevoie, pentru a
 evita multiplele ramificari, de instructiuni de tip "sle" care sa accepte
 operanzi in virgula mobila; intrucat asemenea instructiuni nu au fost
 gasite in cartea [1], am simulat efectul lor cu niste artificii; de ex.
 pentru a evalua "$t4 = 0<=x", adica "$t4 = 0<=$f0" am efectuat:

    li $t0,0           # $t0=false
    li $t2,1           # $t2=true
    li.d $f2,0.0       # $f2=0
    c.le.d $f2,$f0     # flag-ul 0 al cop. 1 devine 1 daca 0<=x, si 0 altfel
    mtc1.d $t0,$f2     # $f2=false
    mtc1.d $t2,$f4     # $f4=true
    movt.d $f2,$f4,0   # daca flag-ul 0 e 1, $f2 ia val. $f4, adica true
    mfc1.d $t4,$f2     # $t4=val. de adevar a lui "0<=x"

 echivalent, in locul ultimelor doua instructiuni am fi putut efectua:

    movf.d $f4,$f2,0   # daca flag-ul 0 e 0, $f4 ia val. $f2, adica false
    mfc1.d $t4,$f4     # $t4=val. de adevar a lui "0<=x"

 ne-am bazat pe faptul ca "mtc1.d" si "mfc1.d" copiaza configuratiile, nu
 schimba modul de reprezentare a valorilor (deci din $t-uri se copiaza in
 $f-uri 1 si 0 ca intregi, apoi inapoi in $t4 tot ca intregi);
  mentionam ca "mtc1.d" si "mfc1.d" afecteaza de fapt perechile ($t0,$t1),
 ($t2,$t3), resp. ($t4,$t5) pe de-o parte si ($f2,$f3), resp. ($f4,$f5) pe
 de alta parte; dar, indiferent ce contin sau vor contine $t1, $t3, $t5,
 $f3, $f4 tot ce ne intereseaza se transfera doar intre $t0, $t2, $t4, $f2,
 $f4; de aceea de ex. nu a trebuit sa initializam si $t1, $t3;
- in cartea [1] nu am gasit conventii MIPS referitoare la salvarea/
 restaurarea registrilor coprocesorului 1 cu ocazia apelurilor de proceduri;
 in absenta unor asemenea conventii i-am considerat callee-saved;
- in procedura "reprezinta" trebuie salvat/restaurat $ra, deoarece face
 apeluri imbricate (prin acel "(*f)(x)"); in "sin", "parabola" si "dreapta"
 nu e necesar, dar am rezervat un word in plus in cadru pentru a pastra
 alinierea adreselor la multipli de 8.
